/**
 * SEQUENTIAL SIDEBAR CONTROLLER
 * Phase 3: Complete JavaScript Logic
 * 
 * Features:
 * - 3-state sidebar (closed/half/full)
 * - Drag handle toggle
 * - Timeline rendering
 * - Real-time updates
 * - Step animations
 */

class SequentialSidebar {
    constructor() {
        this.sidebar = null;
        this.handle = null;
        this.timeline = null;
        this.progressBar = null;
        this.statusBadge = null;
        this.progressText = null;
        this.emptyState = null;
        
        this.currentState = 'closed'; // closed, half, full
        this.activeTaskId = null;
        this.steps = new Map(); // stepId -> stepElement
        
        this.init();
    }
    
    /**
     * Initialize sidebar and attach event listeners
     */
    init() {
        console.log('[SequentialSidebar] Initializing...');
        
        // Get DOM elements
        this.sidebar = document.getElementById('sequential-sidebar');
        this.handle = document.getElementById('sidebar-handle');
        this.timeline = document.getElementById('sidebar-timeline');
        this.progressBar = document.getElementById('sidebar-progress-bar');
        this.statusBadge = document.getElementById('sidebar-status-badge');
        this.progressText = document.getElementById('sidebar-progress-text');
        this.emptyState = document.getElementById('sidebar-empty-state');
        
        if (!this.sidebar) {
            console.error('[SequentialSidebar] Sidebar element not found!');
            return;
        }
        
        // Attach event listeners
        this.handle.addEventListener('click', () => this.toggle());
        
        // Keyboard shortcut: Ctrl+Shift+S to toggle
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                this.toggle();
            }
        });
        
        console.log('[SequentialSidebar] Initialized successfully');
    }
    
    /**
     * Open sidebar to specified state
     * @param {string} state - 'half' or 'full'
     */
    open(state = 'half') {
        if (state !== 'half' && state !== 'full') {
            console.warn(`[SequentialSidebar] Invalid state: ${state}, defaulting to 'half'`);
            state = 'half';
        }
        
        console.log(`[SequentialSidebar] Opening to ${state} state`);
        this.currentState = state;
        this.sidebar.setAttribute('data-state', state);
        
        // Update handle icon
        this.updateHandleIcon();
    }
    
    /**
     * Close sidebar (show only handle)
     */
    close() {
        console.log('[SequentialSidebar] Closing');
        this.currentState = 'closed';
        this.sidebar.setAttribute('data-state', 'closed');
        this.updateHandleIcon();
    }
    
    /**
     * Toggle between closed and last open state
     */
    toggle() {
        if (this.currentState === 'closed') {
            // Open to half by default
            this.open('half');
        } else {
            // Close
            this.close();
        }
    }
    
    /**
     * Update handle icon based on state
     */
    updateHandleIcon() {
        const icon = this.handle.querySelector('i[data-lucide]');
        if (icon) {
            // Icon rotation is handled by CSS
            // Just refresh lucide icons
            if (window.lucide) {
                window.lucide.createIcons();
            }
        }
    }
    
    /**
     * Start a new sequential task
     * @param {string} taskId - Unique task identifier
     * @param {object} data - Task data with title, description, etc.
     */
    startTask(taskId, data = {}) {
        console.log(`[SequentialSidebar] Starting task: ${taskId}`, data);
        
        this.activeTaskId = taskId;
        
        // Clear previous steps
        this.clearTimeline();
        
        // Update status badge
        this.updateStatus('running');
        
        // Update progress
        this.updateProgress(0, 'Starting sequential task...');
        
        // Auto-open sidebar
        if (this.currentState === 'closed') {
            this.open('half');
        }
    }
    
    /**
     * Clear all steps from timeline
     */
    clearTimeline() {
        // Remove all steps except empty state
        const steps = this.timeline.querySelectorAll('.sidebar-step');
        steps.forEach(step => step.remove());
        
        // Clear steps map
        this.steps.clear();
        
        // Show empty state
        if (this.emptyState) {
            this.emptyState.style.display = 'block';
        }
    }
    
    /**
     * Update status badge
     * @param {string} status - 'idle', 'running', 'complete', 'failed'
     */
    updateStatus(status) {
        if (!this.statusBadge) return;
        
        this.statusBadge.setAttribute('data-status', status);
        
        const statusText = {
            idle: 'Idle',
            running: 'Running',
            complete: 'Complete',
            failed: 'Failed'
        };
        
        const textSpan = this.statusBadge.querySelector('span');
        if (textSpan) {
            textSpan.textContent = statusText[status] || status;
        }
        
        // Update lucide icon
        if (window.lucide) {
            window.lucide.createIcons();
        }
    }
    
    /**
     * Update progress bar
     * @param {number} percent - Progress percentage (0-100)
     * @param {string} text - Progress text
     */
    updateProgress(percent, text = '') {
        if (this.progressBar) {
            this.progressBar.style.width = `${Math.min(100, Math.max(0, percent))}%`;
        }
        
        if (this.progressText && text) {
            this.progressText.textContent = text;
        }
    }
    
    /**
     * Add a new step to the timeline
     * @param {object} stepData - Step data
     */
    addStep(stepData) {
        const {
            id,
            title = 'Untitled Step',
            description = '',
            status = 'pending',
            timestamp = new Date()
        } = stepData;
        
        console.log(`[SequentialSidebar] Adding step: ${id}`, stepData);
        
        // Hide empty state
        if (this.emptyState) {
            this.emptyState.style.display = 'none';
        }
        
        // Clone template
        const template = document.getElementById('sidebar-step-template');
        if (!template) {
            console.error('[SequentialSidebar] Step template not found!');
            return;
        }
        
        const stepElement = template.content.cloneNode(true).querySelector('.sidebar-step');
        
        // Set step data
        stepElement.setAttribute('data-step-id', id);
        stepElement.setAttribute('data-status', status);
        
        // Set content
        const titleEl = stepElement.querySelector('.sidebar-step-title');
        const descEl = stepElement.querySelector('.sidebar-step-description');
        const timeEl = stepElement.querySelector('.sidebar-step-time');
        
        if (titleEl) titleEl.textContent = title;
        if (descEl) descEl.textContent = description;
        if (timeEl) timeEl.textContent = this.formatTime(timestamp);
        
        // Add to timeline
        this.timeline.appendChild(stepElement);
        
        // Store reference
        this.steps.set(id, stepElement);
        
        // Refresh lucide icons
        if (window.lucide) {
            window.lucide.createIcons();
        }
        
        // Scroll to bottom
        this.timeline.scrollTop = this.timeline.scrollHeight;
        
        return stepElement;
    }
    
    /**
     * Update an existing step
     * @param {string} stepId - Step identifier
     * @param {object} newData - Updated data
     */
    updateStep(stepId, newData) {
        const stepElement = this.steps.get(stepId);
        if (!stepElement) {
            console.warn(`[SequentialSidebar] Step not found: ${stepId}`);
            return;
        }
        
        console.log(`[SequentialSidebar] Updating step: ${stepId}`, newData);
        
        // Update status
        if (newData.status) {
            stepElement.setAttribute('data-status', newData.status);
            this.animateStatus(stepElement, newData.status);
        }
        
        // Update title
        if (newData.title) {
            const titleEl = stepElement.querySelector('.sidebar-step-title');
            if (titleEl) titleEl.textContent = newData.title;
        }
        
        // Update description
        if (newData.description) {
            const descEl = stepElement.querySelector('.sidebar-step-description');
            if (descEl) descEl.textContent = newData.description;
        }
        
        // Update time
        if (newData.timestamp) {
            const timeEl = stepElement.querySelector('.sidebar-step-time');
            if (timeEl) timeEl.textContent = this.formatTime(newData.timestamp);
        }
        
        // Refresh lucide icons
        if (window.lucide) {
            window.lucide.createIcons();
        }
    }
    
    /**
     * Animate status change
     * @param {HTMLElement} stepElement - Step element
     * @param {string} status - New status
     */
    animateStatus(stepElement, status) {
        const icon = stepElement.querySelector('.sidebar-step-icon');
        if (!icon) return;
        
        // Add pulse animation
        icon.style.transform = 'scale(1.2)';
        setTimeout(() => {
            icon.style.transform = 'scale(1)';
        }, 200);
    }
    
    /**
     * Complete the current task
     * @param {boolean} success - Whether task completed successfully
     */
    completeTask(success = true) {
        console.log(`[SequentialSidebar] Task ${success ? 'completed' : 'failed'}: ${this.activeTaskId}`);
        
        // Update status
        this.updateStatus(success ? 'complete' : 'failed');
        
        // Update progress
        this.updateProgress(100, success ? 'Task completed!' : 'Task failed');
        
        // Clear active task after delay
        setTimeout(() => {
            this.activeTaskId = null;
        }, 3000);
    }
    
    /**
     * Format timestamp
     * @param {Date|string} timestamp - Timestamp to format
     * @returns {string} Formatted time
     */
    formatTime(timestamp) {
        const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
        return date.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }
    
    /**
     * Render complete progress data (for polling updates)
     * @param {object} data - Progress data from API
     */
    renderProgress(data) {
        if (!data) return;
        
        console.log('[SequentialSidebar] Rendering progress', data);
        
        // Update status
        if (data.status) {
            this.updateStatus(data.status);
        }
        
        // Update progress
        if (typeof data.progress === 'number') {
            this.updateProgress(data.progress, data.message || '');
        }
        
        // Render steps
        if (data.steps && Array.isArray(data.steps)) {
            this.renderSteps(data.steps);
        }
    }
    
    /**
     * Render multiple steps
     * @param {Array} steps - Array of step data
     */
    renderSteps(steps) {
        steps.forEach(stepData => {
            const existingStep = this.steps.get(stepData.id);
            
            if (existingStep) {
                // Update existing step
                this.updateStep(stepData.id, stepData);
            } else {
                // Add new step
                this.addStep(stepData);
            }
        });
    }
}

// Initialize on DOM ready
let sequentialSidebar = null;

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        sequentialSidebar = new SequentialSidebar();
        window.sequentialSidebar = sequentialSidebar;
    });
} else {
    sequentialSidebar = new SequentialSidebar();
    window.sequentialSidebar = sequentialSidebar;
}

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SequentialSidebar;
}
